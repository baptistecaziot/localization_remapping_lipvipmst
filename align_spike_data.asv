
function [dataset,collapsed] = align_spike_data(dataset, settings)

% =========================================================================
% Script: align_spike_data.m
%
% Description:
% This script performs preprocessing and alignment of spike data across
% multiple experimental sessions. It detects stimulus onsets, aligns spike
% trains to key behavioral events (stimulus, saccade, jump), bins the data
% into firing rates, and identifies perisaccadic trials based on timing
% thresholds. It also computes neuron activity masks based on firing rate
% thresholds and checks consistency across alignments.
% The output includes structured containers for further analysis and
% visualizations.
%
% Key Features:
% - Detects stimulus onset using prioritized channels (7 then 4)
% - Aligns spike data to stimulus, saccade, and jump events
% - Converts raw spike trains into binned firing rates (Hz)
% - Identifies perisaccadic trials based on stimulus-saccade timing
% - Excludes invalid trials with detailed logging
% - Computes active neuron masks per alignment
% - Verifies mask consistency across alignments
% - Summaries and metadata export
%
% Requirements:
% - 'dataset' structure with spike_data, saccade info, and event timings
% - Functions: compute_trial_indices, find_stim_onsets
%
% =========================================================================
    
    %% ------------------ User/session parameters --------------------------------------------
    % Sessions and neurons
    n_sessions = numel(dataset);
    n_neurons  = dataset(1).spike_channels_number;
    n_conditions_peri = numel(settings.conditions_perisaccadic);
    n_conditions_trans = numel(settings.conditions_transsaccadic);
    n_conditions_sac = numel(settings.conditions_saccade);
    alignments = {'saccade', 'stimulus', 'jump'};

    %% --- 0) Trial indices and sizes -----------------------------------------
    
    % Compute trial indices per (condition, session), and max per cell
    [trial_idx_peri, trials_num_peri, trial_idx_trans, trials_num_trans, trial_idx_peri, trials_num_peri] = ...
        compute_trial_indices(dataset, settings);
    
    % Global maximum trials across all (cond x session) to preallocate [trial] dim in the 5D matrices 
    max_trial_peri = max(trials_num_peri(:));
    max_trial_trans = max(trials_num_trans(:));
    max_trial_sac = max(trials_num_sac(:));
    
    % Maximum trial length [samples] across sessions — to preallocate [time] dim
    max_trial_len_samples = max(arrayfun(@(x) size(x.spike_data, 2), dataset));
    
    
    %% --- 1) Stimulus detection (per session, trial) -------------------------
    % Detect stimulus onsets per trial using channel priority trigger_channels.
    % The function also produces per-condition presence/absence for diagnostics.
    
    if settings.verbosity
        fprintf('Find stim onsets\n');
    end

    dataset = find_trigger_onsets(dataset, settings);
    
    
    %% --- 2) Preallocate 5D containers ---------------------------------------
    % Shapes: [trial x time/bins x condition x neuron x session]
    % - spike_data_raw.(align): raw samples aligned (time dimension = samples)
    % - spike_data_win.(align): counts per bin (time dimension = bins)
    % - spike_data_binned.(align): firing rate (Hz), same shape as counts
    % - spike_data_valid.(align): boolean mask for valid bins
%     spike_data_raw    = struct();
%     spike_data_win    = struct();
%     spike_data_binned = struct();
%     spike_data_valid  = struct();
    spike_data_peri_raw    = struct();
    spike_data_peri_filtered = struct();
    spike_data_trans_raw    = struct();
    spike_data_trans_filtered = struct();
    spike_data_sac_raw    = struct();
    spike_data_sac_filtered = struct();
    
%     peri_saccadic_mat =  NaN(max_trial_cond, n_conditions, n_sessions);
    
    for align_num = 1:numel(alignments)
        align_name = alignments{align_num};

        spike_data_peri_raw.(align_name)      =  NaN(max_trial_peri, settings.n_bins, n_conditions_peri, n_neurons, n_sessions);
        spike_data_peri_filtered.(align_name) =  NaN(max_trial_peri, settings.n_bins, n_conditions_peri, n_neurons, n_sessions);
        spike_data_trans_raw.(align_name)      =  NaN(max_trial_peri, settings.n_bins, n_conditions_trans, n_neurons, n_sessions);
        spike_data_trans_filtered.(align_name) =  NaN(max_trial_peri, settings.n_bins, n_conditions_trans, n_neurons, n_sessions);
        spike_data_sac_raw.(align_name)      =  NaN(max_trial_peri, settings.n_bins, n_conditions_sac, n_neurons, n_sessions);
        spike_data_sac_filtered.(align_name) =  NaN(max_trial_peri, settings.n_bins, n_conditions_sac, n_neurons, n_sessions);
    end
    
    
    %% --- 3) Align data for peri-saccadic trials -------------------------------------
    
    if settings.verbosity
        fprintf('Align peri-saccadic trials\n');
    end
    
    for session_num=1:n_sessions
        session_dataset = dataset(session_num);
        session_trials_num = session_dataset.trials_number;
        trial_len = size(session_dataset.spike_data, 2);     % [samples per trial]
        n_neurons_session = size(session_dataset.spike_data, 3);

        if settings.verbosity>1
            fprintf('Session %d/%d : %d trials, %d samples per trial\n', session_num, n_sessions, session_trials_num, trial_len);
        end
        
        for cond_num = 1:n_conditions_peri
            cond_id = settings.conditions_perisaccadic(cond_num);
            cond_trials_idx = trial_idx_peri{cond_num, session_num};
            cond_trials_num = numel(cond_trials_idx);
            
            stim_sac_diff_mat = NaN(cond_trials_num, n_conditions_peri, n_sessions);

            for align_num = 1:numel(alignments)
                align_name = alignments{align_num};
                
                for tmp_trial_num = 1:cond_trials_num
                    tmp_trial_idx = cond_trials_idx(tmp_trial_num);
                    
                    % Skip trial if not good triggers
                    if session_dataset.triggers.good_triggers(tmp_trial_idx)

                        % ---- 3.1 Determine alignment onset (in samples) ----
                        onset_samples = NaN;
                        
                        % Get stimulus onset
                        stim_onset_ms = session_dataset.triggers.measured_triggers(tmp_trial_idx,1);
                        
                        % Get saccade onset
                        saccade_onset_ms = session_dataset.saccade.saccade_onsets(tmp_trial_idx);
    
                        % Compute signed time difference (in ms) between stimulus offset and saccade onset
                        % Negative = stimulus before saccade, Positive = stimulus after saccade
                        stim_sacc_diff_ms = stim_onset_ms - saccade_onset_ms;
            
                        switch align_name
                            case 'saccade'
                                onset_samples = session_dataset.saccade.saccade_onsets(tmp_trial_idx);
                            
                            case 'stimulus'                            
                                onset_samples = stim_onset_ms;
        
                            case 'jump'
                                onset_samples = session_dataset.events_time(tmp_trial_idx, 2); % event column 2 = jump --> its written int
                        end
    
                        % ---- 3.3 Compute window indices (in samples) ----
                        window_start_samples = round(settings.time_window(1) * settings.sr_neu / 1000); % [samples]
                        window_end_samples   = round(settings.time_window(2) * settings.sr_neu / 1000); % [samples]
        
                        % If you adopt the safer delay handling, adjust here:
                        start_idx = round(onset_samples + window_start_samples);
                        end_idx   = round(onset_samples + window_end_samples - 1);
        
    
                        % ---- 3.4 Clamp window to valid bounds and build aligned array ----
                        valid_start = max(1, start_idx);
                        valid_end   = min(trial_len, end_idx);
        
                        % Expected aligned window length [samples]
                        expected_len = window_end_samples - window_start_samples;
        
                        % Allocate aligned raw buffer (zeros → implicit padding where outside)
                        aligned_raw = NaN(expected_len, n_neurons_session);
                        aligned_filtered = NaN(expected_len, n_neurons_session);
        
                        % Compute insertion positions inside the aligned buffer
                        insert_start = valid_start - start_idx + 1;
                        insert_end   = insert_start + (valid_end - valid_start);
        
                        clipped_spikes = squeeze(session_dataset.spike_data(tmp_trial_idx, valid_start:valid_end, :));
                        clipped_spikes_filtered = squeeze(session_dataset.spike_data_filtered(tmp_trial_idx, valid_start:valid_end, :));
                        
                        try
                            aligned_raw(insert_start:insert_end, :) = clipped_spikes;
                            aligned_filtered(insert_start:insert_end, :) = clipped_spikes_filtered;
                        catch ME
                            keyboard;
                        end
                        % Store aligned raw
                        dataset(session_num).neural.peri.raw.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session) = aligned_raw;
                        dataset(session_num).neural.peri.filtered.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session) = aligned_filtered;
        
                        stim_sac_diff_mat(tmp_trial_num, cond_num, session_num) = stim_sacc_diff_ms;
                        spike_data_peri_raw.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session, session_num) = aligned_raw;
                        spike_data_peri_filtered.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session, session_num) = aligned_filtered;
                    
                    end % good_triggers
                end % trials
            end % alignments
        end % conditions
    end % sessions

    collapsed.peri.stim_sac_diff_mat = stim_sac_diff_mat;
    collapsed.peri.spike_data_raw = spike_data_peri_raw;
    collapsed.peri.spike_data_filtered = spike_data_peri_filtered;


    %% --- 4) Align data for trans-saccadic trials -------------------------------------
    
    if settings.verbosity
        fprintf('Align trans-saccadic trials\n');
    end
    
    for session_num=1:n_sessions
        session_dataset = dataset(session_num);
        session_trials_num = session_dataset.trials_number;
        trial_len = size(session_dataset.spike_data, 2);     % [samples per trial]
        n_neurons_session = size(session_dataset.spike_data, 3);

        if settings.verbosity>1
            fprintf('Session %d/%d : %d trials, %d samples per trial\n', session_num, n_sessions, session_trials_num, trial_len);
        end
        
        for cond_num = 1:n_conditions_trans
            cond_id = settings.conditions_transsaccadic(cond_num);
            cond_trials_idx = trial_idx_trans{cond_num, session_num};
            cond_trials_num = numel(cond_trials_idx);
            
            for align_num = 1:numel(alignments)
                align_name = alignments{align_num};
                
                for tmp_trial_num = 1:cond_trials_num
                    tmp_trial_idx = cond_trials_idx(tmp_trial_num);
                    
                    % Skip trial if not good triggers
                    if session_dataset.triggers.good_triggers(tmp_trial_idx)

                        % ---- 3.1 Determine alignment onset (in samples) ----
                        onset_samples = NaN;
                        
                        % Get stimulus onset
                        stim_onset_ms = session_dataset.triggers.measured_triggers(tmp_trial_idx,1);
                        
                        % Get saccade onset
                        saccade_onset_ms = session_dataset.saccade.saccade_onsets(tmp_trial_idx);
    
                        % Compute signed time difference (in ms) between stimulus offset and saccade onset
                        % Negative = stimulus before saccade, Positive = stimulus after saccade
                        stim_sacc_diff_ms = stim_onset_ms - saccade_onset_ms;
            
                        switch align_name
                            case 'saccade'
                                onset_samples = session_dataset.saccade.saccade_onsets(tmp_trial_idx);
                            
                            case 'stimulus'                            
                                onset_samples = stim_onset_ms;
        
                            case 'jump'
                                onset_samples = session_dataset.events_time(tmp_trial_idx, 2); % event column 2 = jump --> its written int
                        end
    
                        % ---- 3.3 Compute window indices (in samples) ----
                        window_start_samples = round(settings.time_window(1) * settings.sr_neu / 1000); % [samples]
                        window_end_samples   = round(settings.time_window(2) * settings.sr_neu / 1000); % [samples]
        
                        % If you adopt the safer delay handling, adjust here:
                        start_idx = round(onset_samples + window_start_samples);
                        end_idx   = round(onset_samples + window_end_samples - 1);
        
    
                        % ---- 3.4 Clamp window to valid bounds and build aligned array ----
                        valid_start = max(1, start_idx);
                        valid_end   = min(trial_len, end_idx);
        
                        % Expected aligned window length [samples]
                        expected_len = window_end_samples - window_start_samples;
        
                        % Allocate aligned raw buffer (zeros → implicit padding where outside)
                        aligned_raw = NaN(expected_len, n_neurons_session);
                        aligned_filtered = NaN(expected_len, n_neurons_session);
        
                        % Compute insertion positions inside the aligned buffer
                        insert_start = valid_start - start_idx + 1;
                        insert_end   = insert_start + (valid_end - valid_start);
        
                        clipped_spikes = squeeze(session_dataset.spike_data(tmp_trial_idx, valid_start:valid_end, :));
                        clipped_spikes_filtered = squeeze(session_dataset.spike_data_filtered(tmp_trial_idx, valid_start:valid_end, :));
                        
                        try
                            aligned_raw(insert_start:insert_end, :) = clipped_spikes;
                            aligned_filtered(insert_start:insert_end, :) = clipped_spikes_filtered;
                        catch ME
                            keyboard;
                        end
                        % Store aligned raw
                        dataset(session_num).neural.trans.raw.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session) = aligned_raw;
                        dataset(session_num).neural.trans.filtered.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session) = aligned_filtered;
        
                        stim_sac_diff_mat(tmp_trial_num, cond_num, session_num) = stim_sacc_diff_ms;
                        spike_data_trans_raw.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session, session_num) = aligned_raw;
                        spike_data_trans_filtered.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session, session_num) = aligned_filtered;
                    
                    end % good_triggers
                end % trials
            end % alignments
        end % conditions
    end % sessions

    collapsed.trans.stim_sac_diff_mat = stim_sac_diff_mat;
    collapsed.trans.spike_data_raw = spike_data_trans_raw;
    collapsed.trans.spike_data_filtered = spike_data_trans_filtered;


    %% --- 5) Align data for saccade-only trials -------------------------------------
    
    if settings.verbosity
        fprintf('Align saccade-only trials\n');
    end
    
    for session_num=1:n_sessions
        session_dataset = dataset(session_num);
        session_trials_num = session_dataset.trials_number;
        trial_len = size(session_dataset.spike_data, 2);     % [samples per trial]
        n_neurons_session = size(session_dataset.spike_data, 3);

        if settings.verbosity>1
            fprintf('Session %d/%d : %d trials, %d samples per trial\n', session_num, n_sessions, session_trials_num, trial_len);
        end
        
        for cond_num = 1:n_conditions_sac
            cond_id = settings.conditions_saccade(cond_num);
            cond_trials_idx = trial_idx_sac{cond_num, session_num};
            cond_trials_num = numel(cond_trials_idx);
            
            for align_num = 1:numel(alignments)
                align_name = alignments{align_num};
                
                for tmp_trial_num = 1:cond_trials_num
                    tmp_trial_idx = cond_trials_idx(tmp_trial_num);
                    
                    % ---- 3.1 Determine alignment onset (in samples) ----
                    onset_samples = NaN;
                    
                    % Get stimulus onset
                    stim_onset_ms = session_dataset.triggers.measured_triggers(tmp_trial_idx,1);
                    
                    % Get saccade onset
                    saccade_onset_ms = session_dataset.saccade.saccade_onsets(tmp_trial_idx);

                    % Compute signed time difference (in ms) between stimulus offset and saccade onset
                    % Negative = stimulus before saccade, Positive = stimulus after saccade
                    stim_sacc_diff_ms = stim_onset_ms - saccade_onset_ms;
        
                    switch align_name
                        case 'saccade'
                            onset_samples = session_dataset.saccade.saccade_onsets(tmp_trial_idx);
                        
                        case 'stimulus'                            
                            onset_samples = stim_onset_ms;
    
                        case 'jump'
                            onset_samples = session_dataset.events_time(tmp_trial_idx, 2); % event column 2 = jump --> its written int
                    end

                    % ---- 3.3 Compute window indices (in samples) ----
                    window_start_samples = round(settings.time_window(1) * settings.sr_neu / 1000); % [samples]
                    window_end_samples   = round(settings.time_window(2) * settings.sr_neu / 1000); % [samples]
    
                    % If you adopt the safer delay handling, adjust here:
                    start_idx = round(onset_samples + window_start_samples);
                    end_idx   = round(onset_samples + window_end_samples - 1);
    

                    % ---- 3.4 Clamp window to valid bounds and build aligned array ----
                    valid_start = max(1, start_idx);
                    valid_end   = min(trial_len, end_idx);
    
                    % Expected aligned window length [samples]
                    expected_len = window_end_samples - window_start_samples;
    
                    % Allocate aligned raw buffer (zeros → implicit padding where outside)
                    aligned_raw = NaN(expected_len, n_neurons_session);
                    aligned_filtered = NaN(expected_len, n_neurons_session);
    
                    % Compute insertion positions inside the aligned buffer
                    insert_start = valid_start - start_idx + 1;
                    insert_end   = insert_start + (valid_end - valid_start);
    
                    clipped_spikes = squeeze(session_dataset.spike_data(tmp_trial_idx, valid_start:valid_end, :));
                    clipped_spikes_filtered = squeeze(session_dataset.spike_data_filtered(tmp_trial_idx, valid_start:valid_end, :));
                    
                    try
                        aligned_raw(insert_start:insert_end, :) = clipped_spikes;
                        aligned_filtered(insert_start:insert_end, :) = clipped_spikes_filtered;
                    catch ME
                        keyboard;
                    end
                    % Store aligned raw
                    dataset(session_num).neural.sac.raw.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session) = aligned_raw;
                    dataset(session_num).neural.sac.filtered.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session) = aligned_filtered;
    
                    stim_sac_diff_mat(tmp_trial_num, cond_num, session_num) = stim_sacc_diff_ms;
                    spike_data_sac_raw.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session, session_num) = aligned_raw;
                    spike_data_sac_filtered.(align_name)(tmp_trial_num, :, cond_num, 1:n_neurons_session, session_num) = aligned_filtered;
                
                end % trials
            end % alignments
        end % conditions
    end % sessions
    
    collapsed.sac.stim_sac_diff_mat = stim_sac_diff_mat;
    collapsed.sac.spike_data_raw = spike_data_trans_raw;
    collapsed.sac.spike_data_filtered = spike_data_trans_filtered;

end



%% ------------------ Helper functions ------------------------------------
function [trials_idx_peri, trials_num_peri, trials_idx_trans, trials_num_trans, trials_idx_sac, trials_num_sac] =...
    compute_trial_indices(dataset, settings)
    % compute_trial_indices
    % Returns:
    % - trial_idx_cond: cell [n_conditions x n_sessions], trial indices per condition/session
    % - max_trials_per_cond_session: [n_conditions x n_sessions] counts per cell
    n_sessions   = numel(dataset);
    n_conditions_peri = numel(settings.conditions_perisaccadic);
    trials_idx_peri = cell(n_conditions_peri, n_sessions);
    trials_num_peri = zeros(n_conditions_peri, n_sessions);
    n_conditions_trans = numel(settings.conditions_transsaccadic);
    trials_idx_trans = cell(n_conditions_trans, n_sessions);
    trials_num_trans = zeros(n_conditions_trans, n_sessions);
    n_conditions_sac = numel(settings.conditions_saccade);
    trials_idx_sac = cell(n_conditions_sac, n_sessions);
    trials_num_sac = zeros(n_conditions_sac, n_sessions);
    
    % Trial indices peri-saccadic
    for session_num = 1:n_sessions
        session = dataset(session_num);
        for cond_num = 1:n_conditions_peri
            cond_id = settings.conditions_perisaccadic(cond_num);
            trials = find(session.stim_data(:, 3) == cond_id); % assumes col 3 holds condition ID
            trials_idx_peri{cond_num, session_num} = trials;
            trials_num_peri(cond_num, session_num) = numel(trials);
        end
    end

    % Trial indices trans-saccadic
    for session_num = 1:n_sessions
        session = dataset(session_num);
        for cond_num = 1:n_conditions_trans
            cond_id = settings.conditions_transsaccadic(cond_num);
            trials = find(session.stim_data(:, 3) == cond_id); % assumes col 3 holds condition ID
            trials_idx_trans{cond_num, session_num} = trials;
            trials_num_trans(cond_num, session_num) = numel(trials);
        end
    end

    % Trial indices saccade only
    for session_num = 1:n_sessions
        session = dataset(session_num);
        for cond_num = 1:n_conditions_sac
            cond_id = settings.conditions_saccade(cond_num);
            trials = find(session.stim_data(:, 3) == cond_id); % assumes col 3 holds condition ID
            trials_idx_sac{cond_num, session_num} = trials;
            trials_num_sac(cond_num, session_num) = numel(trials);
        end
    end
end

function dataset = find_trigger_onsets(dataset, settings)
    % find_stim_onsets
    % Detect TTL-based trigger onsets per trial and compute per-condition presence stats.
    % Priority: trigger_channels(1) first, then trigger_channels(2).
    %
   
    n_sessions = numel(dataset);    

    for session_num = 1:n_sessions
        session = dataset(session_num);
        n_trials = session.trials_number;

        session_conditions_list = session.global_params(:,1);

        % Compute when triggers are expected from condition
        session_expected_triggers = NaN(n_trials,2);
        % Expect 1 trigger in perisaccadic trials
        perisaccadic_mask = any(settings.conditions_perisaccadic==session_conditions_list,2);
        session_expected_triggers(perisaccadic_mask,1) = session.stim_data(perisaccadic_mask,5)-settings.events_delay_ms;
        % Expect 2 triggers in transsaccadic trials
        transsaccadic_mask = any(settings.conditions_transsaccadic==session_conditions_list,2);
        session_expected_triggers(transsaccadic_mask,:) = session.stim_data(transsaccadic_mask,[5,7])-settings.events_delay_ms;
        % Expect no triggers in saccadic trials so do nothing
        
        session_measured_triggers = NaN(n_trials,2);
        session_good_triggers = zeros(n_trials,1);

        if settings.verbosity>1
            fprintf('Searching for stimulus onsets in session %d/%d...\n', session_num, n_sessions);
        end
        
        % First figure whether triggers are on channel 7 or 4
        for ch_try = 1:numel(settings.trigger_channels)
            ch = settings.trigger_channels(ch_try);
            stim_mat = session.spike_data(:, :, ch);
            n_triggers = sum(stim_mat==1, 2);

            % At least 1 trigger per trial on average
            if mean(n_triggers)>1
                session_trigger_channel = ch;
                break;
            end
        end
        
        % Then find triggers trial per trial
        for trial = 1:n_trials
            stim_vec = session.spike_data(trial, :, session_trigger_channel);
            triggers_idx = find(stim_vec==1);
            tmp_triggers = Inf(1,2);

            if any(session_conditions_list(trial)==settings.conditions_perisaccadic)
                % We expect only 1 trigger
                if ~isempty(triggers_idx)
                    tmp_triggers(1) = triggers_idx(1);
                    tmp_triggers(2) = NaN;
                end
                
            end

            if any(session_conditions_list(trial)==settings.conditions_transsaccadic)
                % We expect 2 triggers
                if (length(triggers_idx)>1)
                    tmp_triggers(1) = triggers_idx(1);
                    tmp_idx = find(triggers_idx-triggers_idx(1)>settings.min_triggers_delay_ms,1);
                    if ~isempty(tmp_idx)
                        tmp_triggers(2) = triggers_idx(tmp_idx);
                    end
                end
            end

            if any(session_conditions_list(trial)==settings.conditions_saccade)
                tmp_triggers(:) = NaN;
            end

            % Make sure triggers are not too far off from expected
            if ~any(abs(session_expected_triggers(trial,:)-tmp_triggers)>settings.max_triggers_delay_ms)
                session_measured_triggers(trial,:) = tmp_triggers;
                session_good_triggers(trial) = 1;
            end

        end

        dataset(session_num).triggers.conditions_list = session_conditions_list;
        dataset(session_num).triggers.expected_triggers = session_expected_triggers;
        dataset(session_num).triggers.measured_triggers = session_measured_triggers;
        dataset(session_num).triggers.good_triggers = session_good_triggers;
    end
    
end

